<!DOCTYPE html>
<html>
<head>
    <title>Model Benchmark Results</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Include Chart.js from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <!-- Include results.js (assumed to be in the same directory) -->
    <script src="results.js"></script>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f4f4f4;
        }
        h1, h2 {
            color: #333;
            text-align: center;
        }
        #chart-container {
            width: 90%;
            max-width: 1000px;
            height: 500px; /* Adjust height as needed */
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }
        #top-models-container {
            display: flex;
            justify-content: space-around;
            width: 90%;
            max-width: 1000px;
            margin-top: 20px;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
        }
        .top-list {
            background-color: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin: 10px;
            min-width: 250px; /* Ensure lists have some width */
        }
        .top-list h3 {
            margin-top: 0;
            color: #555;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        .top-list ol {
            padding-left: 20px;
            margin-bottom: 0;
        }
        .top-list li {
            margin-bottom: 8px;
            display: flex;
            align-items: center;
        }
        .color-swatch {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 8px;
            border: 1px solid #ccc;
            flex-shrink: 0; /* Prevent swatch from shrinking */
        }
        .model-name {
            font-weight: bold;
            margin-right: 5px;
        }
        .model-score {
            color: #777;
            font-size: 0.9em;
        }

        /* Add some space for the legend */
        #chart-container canvas {
            max-height: calc(100% - 40px); /* Adjust if legend position changes */
        }

    </style>
</head>
<body>
    <h1>Model Benchmark Comparison</h1>

    <div id="chart-container">
        <canvas id="benchmarkChart"></canvas>
    </div>

    <h2>Top 3 Models per Benchmark</h2>
    <div id="top-models-container">
        <!-- Top models will be populated here by JavaScript -->
    </div>

    <script>
        // --- Configuration ---
        const benchmarkConfig = {
            "aider_polyglot": {
                friendlyName: "Aider polyglot coding leaderboard",
                primaryMetric: "percent_correct",
                yAxisID: 'yPercent',
                labelSuffix: '%'
            },
            "kcores_llm_arena": {
                friendlyName: "KCORES LLM Arena",
                primaryMetric: "normalized_score",
                yAxisID: 'yScore',
                labelSuffix: '' // No suffix for normalized score
            }
        };

        const benchmarkOrder = ["aider_polyglot", "kcores_llm_arena"]; // Define the order of benchmarks on the chart

        // --- Color Palette ---
        // Using a predefined list of distinct colors
        const colorPalette = [
            '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',
            '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf',
            '#aec7e8', '#ffbb78', '#98df8a', '#ff9896', '#c5b0d5',
            '#c49c94', '#f7b6d2', '#c7c7c7', '#dbdb8d', '#9edae5'
        ];

        // Assign a consistent color to each model
        const modelColors = {};
        models.forEach((modelName, index) => {
            modelColors[modelName] = colorPalette[index % colorPalette.length];
        });

        // --- Data Processing ---
        const chartLabels = benchmarkOrder.map(key => benchmarkConfig[key].friendlyName);
        const datasets = [];
        const benchmarkDataForRanking = {}; // To store data for ranking { benchmarkKey: [{ model, score, color }] }

        // Initialize ranking data structure
        benchmarkOrder.forEach(key => {
            benchmarkDataForRanking[key] = [];
        });

        models.forEach(modelName => {
            const modelData = [];
            benchmarkOrder.forEach(benchmarkKey => {
                const benchmarkInfo = benchmarkConfig[benchmarkKey];
                let score = null; // Use null for missing data points

                if (results[modelName] && results[modelName][benchmarkKey]) {
                    score = results[modelName][benchmarkKey][benchmarkInfo.primaryMetric];
                    // Store data for ranking if score is valid
                    if (score !== null && typeof score === 'number') {
                         benchmarkDataForRanking[benchmarkKey].push({
                            model: modelName,
                            score: score,
                            color: modelColors[modelName]
                        });
                    }
                }
                modelData.push(score);
            });

            datasets.push({
                label: modelName,
                data: modelData,
                backgroundColor: modelColors[modelName],
                borderColor: modelColors[modelName],
                borderWidth: 1,
                // Assign dataset to the correct Y axis based on the first benchmark it has data for
                // (This assumes models won't mix axes within their data array, which is true here)
                yAxisID: results[modelName]?.[benchmarkOrder[0]] ? benchmarkConfig[benchmarkOrder[0]].yAxisID :
                         results[modelName]?.[benchmarkOrder[1]] ? benchmarkConfig[benchmarkOrder[1]].yAxisID :
                         benchmarkConfig[benchmarkOrder[0]].yAxisID // Default if no data?
            });
        });

        // --- Calculate Top 3 ---
        const topModels = {};
        benchmarkOrder.forEach(key => {
            // Sort models for this benchmark by score descending
            benchmarkDataForRanking[key].sort((a, b) => b.score - a.score);
            // Get top 3
            topModels[key] = benchmarkDataForRanking[key].slice(0, 3);
        });

        // --- Render Top 3 Lists ---
        const topModelsContainer = document.getElementById('top-models-container');
        topModelsContainer.innerHTML = ''; // Clear previous content

        benchmarkOrder.forEach(key => {
            const benchmarkInfo = benchmarkConfig[key];
            const topList = topModels[key];

            const listDiv = document.createElement('div');
            listDiv.classList.add('top-list');

            const title = document.createElement('h3');
            title.textContent = benchmarkInfo.friendlyName;
            listDiv.appendChild(title);

            const ol = document.createElement('ol');
            if (topList.length > 0) {
                topList.forEach(item => {
                    const li = document.createElement('li');

                    const swatch = document.createElement('span');
                    swatch.classList.add('color-swatch');
                    swatch.style.backgroundColor = item.color;
                    li.appendChild(swatch);

                    const nameSpan = document.createElement('span');
                    nameSpan.classList.add('model-name');
                    nameSpan.textContent = item.model;
                    li.appendChild(nameSpan);

                    const scoreSpan = document.createElement('span');
                    scoreSpan.classList.add('model-score');
                    scoreSpan.textContent = `(${item.score.toFixed(1)}${benchmarkInfo.labelSuffix || ''})`; // Format score
                    li.appendChild(scoreSpan);

                    ol.appendChild(li);
                });
            } else {
                const li = document.createElement('li');
                li.textContent = 'No data available.';
                ol.appendChild(li);
            }
            listDiv.appendChild(ol);
            topModelsContainer.appendChild(listDiv);
        });


        // --- Chart Rendering ---
        const ctx = document.getElementById('benchmarkChart').getContext('2d');
        const benchmarkChart = new Chart(ctx, {
            type: 'bar',
            data: {
                labels: chartLabels,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Benchmark'
                        }
                    },
                    // Define two Y axes
                    [benchmarkConfig.aider_polyglot.yAxisID]: { // e.g., yPercent
                        type: 'linear',
                        position: 'left',
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: `Score (${benchmarkConfig.aider_polyglot.labelSuffix})` // e.g., Score (%)
                        },
                        grid: {
                            drawOnChartArea: false // Only draw grid for the primary axis (optional)
                        }
                    },
                    [benchmarkConfig.kcores_llm_arena.yAxisID]: { // e.g., yScore
                        type: 'linear',
                        position: 'right',
                        beginAtZero: true,
                        title: {
                            display: true,
                            text: `Score (${benchmarkConfig.kcores_llm_arena.labelSuffix || 'Normalized'})` // e.g., Score (Normalized)
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top', // Or 'bottom'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                if (context.parsed.y !== null) {
                                    // Determine the correct suffix based on the dataset's yAxisID
                                    const datasetYAxisID = context.dataset.yAxisID;
                                    let suffix = '';
                                    for (const key in benchmarkConfig) {
                                        if (benchmarkConfig[key].yAxisID === datasetYAxisID) {
                                            suffix = benchmarkConfig[key].labelSuffix || '';
                                            break;
                                        }
                                    }
                                    label += context.parsed.y.toFixed(1) + suffix;
                                }
                                return label;
                            }
                        }
                    },
                    title: {
                        display: false, // Using the main H1 tag instead
                        text: 'Model Benchmark Performance Comparison'
                    }
                },
                // Group bars by benchmark (indexAxis: 'x')
                indexAxis: 'x',
            }
        });

    </script>

</body>
</html>