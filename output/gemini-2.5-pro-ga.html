<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0"
    />
    <title>Model Benchmark Results</title>

    <!-- External library (Chart.js) from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <!-- Data loaded from local file -->
    <script src="results.js"></script>

    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial,
          sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
        margin: 0;
        padding: 2rem;
        background-color: #f8f9fa;
        color: #212529;
        display: flex;
        flex-direction: column;
        align-items: center;
      }
      h1 {
        text-align: center;
        margin-bottom: 2rem;
        color: #343a40;
      }
      .chart-container {
        position: relative;
        margin: auto;
        height: 80vh;
        width: 90vw;
        max-width: 1400px;
      }
    </style>
  </head>
  <body>
    <h1>Model Benchmark Results</h1>
    <div class="chart-container">
      <canvas id="benchmarkChart"></canvas>
    </div>

    <script>
      // --- 1. DEFINE CONSTANTS AND CONFIGURATION ---

      const friendlyNames = {
        aider_polyglot: "Aider polyglot coding leaderboard",
        kcores_llm_arena: "KCORES LLM Arena",
      };

      const benchmarkKeys = Object.keys(friendlyNames);

      // A color palette to assign a unique, consistent color to each model
      const colorPalette = [
        "#4E79A7",
        "#F28E2B",
        "#E15759",
        "#76B7B2",
        "#59A14F",
        "#EDC948",
        "#B07AA1",
        "#FF9DA7",
        "#9C755F",
        "#BAB0AC",
      ];

      const modelColors = {};
      models.forEach((model, index) => {
        modelColors[model] = colorPalette[index % colorPalette.length];
      });

      // --- 2. PROCESS AND NORMALIZE DATA ---

      const chartLabels = benchmarkKeys.map(key => friendlyNames[key]);
      const chartDatasets = [];
      const benchmarkScores = {};
      benchmarkKeys.forEach(key => (benchmarkScores[key] = []));

      models.forEach(modelName => {
        const modelData = results[modelName];
        const datasetData = [];

        // Process 'aider_polyglot'
        const aiderData = modelData.aider_polyglot;
        let aiderScore = null;
        if (aiderData && typeof aiderData.percent_correct !== "undefined") {
          // Already on a 0-100 scale
          aiderScore = aiderData.percent_correct;
          benchmarkScores.aider_polyglot.push({model: modelName, score: aiderScore});
        }
        datasetData.push(aiderScore);

        // Process 'kcores_llm_arena'
        const kcoresData = modelData.kcores_llm_arena;
        let kcoresScore = null;
        if (kcoresData && typeof kcoresData.normalized_score !== "undefined") {
          // Normalize the score from a 0-400 scale to a 0-100 scale
          kcoresScore = (kcoresData.normalized_score / 400) * 100;
          benchmarkScores.kcores_llm_arena.push({model: modelName, score: kcoresScore});
        }
        datasetData.push(kcoresScore);

        // Create the dataset object for Chart.js
        chartDatasets.push({
          label: modelName,
          data: datasetData,
          backgroundColor: modelColors[modelName],
          borderColor: modelColors[modelName],
          borderWidth: 1,
        });
      });

      // --- 3. CALCULATE TOP 3 MODELS FOR EACH BENCHMARK ---

      const top3Models = {};
      benchmarkKeys.forEach(key => {
        const benchmarkName = friendlyNames[key];
        top3Models[benchmarkName] = {};

        // Sort models by score for this benchmark, descending
        const sortedModels = benchmarkScores[key].sort((a, b) => b.score - a.score);

        // Store the rank (1, 2, or 3) for the top 3 models
        sortedModels.slice(0, 3).forEach((entry, rankIndex) => {
          top3Models[benchmarkName][entry.model] = rankIndex + 1;
        });
      });

      // --- 4. CREATE CUSTOM CHART.JS PLUGIN FOR TOP 3 LABELS ---

      const top3LabelsPlugin = {
        id: "top3Labels",
        afterDraw: (chart, args, options) => {
          const {ctx} = chart;
          ctx.save();
          ctx.font = "bold 16px sans-serif";
          ctx.fillStyle = "rgba(0, 0, 0, 0.85)";
          ctx.textAlign = "center";
          ctx.textBaseline = "bottom";

          const topModelsData = options.topModels;
          if (!topModelsData) return;

          // Iterate over each dataset (model) and its bars
          chart.data.datasets.forEach((dataset, i) => {
            const meta = chart.getDatasetMeta(i);
            if (!meta.hidden) {
              // Only draw on visible bars
              meta.data.forEach((bar, index) => {
                const modelName = dataset.label;
                const benchmarkName = chart.data.labels[index];

                // Check if this model is in the top 3 for this benchmark
                const rank = topModelsData[benchmarkName]?.[modelName];

                if (rank) {
                  const emoji = ["üèÜ", "ü•à", "ü•â"][rank - 1];
                  if (emoji) {
                    // Position the emoji just above the bar
                    ctx.fillText(emoji, bar.x, bar.y - 5);
                  }
                }
              });
            }
          });
          ctx.restore();
        },
      };

      // --- 5. RENDER THE CHART ---

      const ctx = document.getElementById("benchmarkChart").getContext("2d");
      const benchmarkChart = new Chart(ctx, {
        type: "bar",
        data: {
          labels: chartLabels,
          datasets: chartDatasets,
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              max: 100,
              title: {
                display: true,
                text: "Normalized Score (0-100)",
                font: {
                  size: 14,
                  weight: "bold",
                },
              },
            },
            x: {
              ticks: {
                font: {
                  size: 14,
                },
              },
            },
          },
          plugins: {
            legend: {
              position: "top",
            },
            title: {
              display: true,
              text: "Relative Model Performance Across Benchmarks",
              font: {
                size: 20,
              },
              padding: {
                bottom: 20,
              },
            },
            tooltip: {
              callbacks: {
                label: function (context) {
                  let label = context.dataset.label || "";
                  if (label) {
                    label += ": ";
                  }
                  if (context.parsed.y !== null) {
                    // Add original score to tooltip for context
                    const modelName = context.dataset.label;
                    const benchmarkKey = benchmarkKeys[context.dataIndex];
                    const originalData = results[modelName][benchmarkKey];
                    let originalScoreText = "";

                    if (benchmarkKey === "kcores_llm_arena" && originalData) {
                      originalScoreText = ` (Original: ${originalData.normalized_score.toFixed(
                        1,
                      )})`;
                    }

                    label += context.parsed.y.toFixed(2) + originalScoreText;
                  }
                  return label;
                },
              },
            },
            // Pass our calculated top models data to our custom plugin
            top3Labels: {
              topModels: top3Models,
            },
          },
        },
        // Register the custom plugin globally for this chart instance
        plugins: [top3LabelsPlugin],
      });
    </script>
  </body>
</html>
